---
title: "To Do List"
output: html_document
---

```{r setup, include=FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(epiR)
library(tidyverse)
```

# Intro
For most of these functions we will have a:

- **tidy.epi_function** which will give a tible with estimates in a tidy form good for plotting and further data manipulation

- **plot.epi_function** which will plot a relevant ggplot

- **tab.epi_function** which will give the cross-tabulation

# Functions needed

### 1. predictive values plot for example
```{r}
# don't laught and write a better one!
plot_predval <-function(se, sp){
p <- seq(1:100)/100
ppv <- (se*p)/((se*p)+((1-sp)*(1-p)))
npv <- sp*(1-p)/((sp*(1-p)+(1-se)*p))
df <- data.frame(p=c(p,p), pv=c(rep("PPV", length(ppv)),rep("NPV", length(ppv))),
                 pv_value=c(ppv, npv))
df$pv <- factor(df$pv, levels = c("PPV", "NPV"))
ggplot(data=df) + geom_point(aes(x=p, y=pv_value, colour=pv)) + 
  labs(x="Prevalence", y="Predictive value", colour="")
}
plot_predval(se=0.95,sp=0.9)
```

### 2. epi_binom
We need a function that takes numbers (successes, total) or data and method for CI calculation. 

epi_binom(data, column, method) but also epi_binom(success, total, method)
```{r}
# currently
dat <- data.frame(Lepto=rbinom(100, 1, 0.05),
                 Brucella=rbinom(100, 1, 0.2),
                 DAge2=rnorm(100, 7, 3),
                 CalfSex= rbinom(100, 1, 0.5))
library(binom)
binom.confint(4, (96+3), 0.95)
binom.confint(sum(dat$Lepto), nrow(subset(dat, !is.na(Lepto))))
```

### 3. epi_confint

I'm a bit lost. This replicates the above. So maybe forget about *epi_binom* and create *epi_confint* which is based on *epi.conf* i.e does estimates and CIs for means, proportions, incidence and standardised mortality ratios. 

```{r}
# currently
library(epiR)
d <- as.matrix(cbind(sum(dat$Lepto),sum(dat$DAge2)),2,1)
d
epi.conf(dat=d,conf.level=0.95, ctype="inc.rate", method = "exact")

# replicates binom.confint
d <- as.matrix(cbind(sum(dat$Lepto), nrow(subset(dat, !is.na(Lepto)))))
epi.conf(dat=d, conf.level = 0.95, ctype = "prevalence", method="exact")
binom.confint(sum(dat$Lepto), nrow(subset(dat, !is.na(Lepto))), methods = "exact")
```


### 4 epi_2by2
We need a function that takes numbers (a,b,c,d) or data and method for epi estimates. 

epi_2by2(data, exposure, response, method) but also epi_2by2(a, b, c, d, method)

Below are examples of all the *methods* used in Mark's lectures. 

```{r, warning=FALSE}
#Currently
# cohort.count
m <- table(dat$CalfSex, dat$Lepto)  
a <- m[1,2]   
b <- m[1,1]
c <- m[2,2]
d <- m[2,1]
leptotable<-matrix(c(a,c,b,d),2,2) 
epi.2by2(leptotable, method="cohort.count")

# cohort.time
tab <-dat %>%
  group_by(CalfSex) %>%
  summarise(Dis=sum(Lepto),
            Time=sum(DAge2))
tab

ir.data <- as.matrix(tab[ ,-1])
epi.2by2(ir.data, method="cohort.time")

ir.data <- as.table(matrix(c(10, 5, 413, 312),2,2))
epi.2by2(ir.data, method="cohort.time")

# cross sectional
epi.2by2(matrix(c(13,5,2163,3349),2,2), method="cross.sectional")

# case control
```

### epi_tests
Ideally we need the same as above. 

epi_tests(data, new_test, gold_standard) but also epi_tests(a, b, c, d)


```{r}
#Currently takes numbers in a numeric vector
library(epiR)
epi.tests(c(165, 15, 24, 796))
epi.tests(matrix(c(165, 15, 24, 796),2,2))
```




